const ls = { get(k, d){ try{ return JSON.parse(localStorage.getItem(k)) ?? d; }catch{ return d; } }, set(k, v){ localStorage.setItem(k, JSON.stringify(v)); } };
const state = { botOn: ls.get('px_bot_on', false), myNumber: ls.get('px_my_number', ''), aiKey: ls.get('px_ai_key', ''), contacts: ls.get('px_contacts', {}), threads: ls.get('px_threads', {}), current: null };
const waDot = byId('waDot'), waLabel = byId('waLabel'), waStatusText = byId('waStatusText')||{textContent:''};
const botBadge = byId('botBadge'), toggleBot = byId('toggleBot');
const myNumber = byId('myNumber'), saveNumber = byId('saveNumber');
const aiKey = byId('aiKey'), saveKey = byId('saveKey');
const btnCheckWA = byId('btnCheckWA');
const contactsList = byId('contactsList');
const cName = byId('cName'), cPhone = byId('cPhone'), cNotes = byId('cNotes'), btnAdd = byId('btnAdd');
const thread = byId('thread'), threadTitle = byId('threadTitle');
const msgText = byId('msgText'), sendMsg = byId('sendMsg');
renderBot(); renderContacts(); renderThread(null);
WABot.init();
WABot.on('status', s => { waDot.classList.toggle('on', !!s.connected); waDot.classList.toggle('off', !s.connected); waLabel.textContent = s.connected ? `WA: on${s.user? ' ('+s.user+')':''}` : 'WA: off'; waStatusText.textContent = s.connected ? 'on' : 'off'; });
WABot.on('message', async (m)=>{ const phone = normalizePhone(m.from || ''); if(!phone) return; upsertContact(phone, {phone, name: m.name || phone, notes: ''}, m.text||'', m.ts||Date.now()); pushMsg(phone, {who:'them', text: m.text||'', ts: m.ts||Date.now()}); if(state.current===phone) renderThread(phone); if(state.botOn && phone !== normalizePhone(state.myNumber)){ try{ const reply = await aiReply({prompt: m.text||'', phone}); if(reply){ await WABot.send({to: phone, text: reply}); pushMsg(phone, {who:'me', text: reply, ts: Date.now()}); if(state.current===phone) renderThread(phone); } }catch(e){} } });
btnCheckWA?.addEventListener('click', ()=> WABot.checkStatus());
toggleBot.addEventListener('click', ()=>{ state.botOn = !state.botOn; ls.set('px_bot_on', state.botOn); renderBot(); });
saveNumber.addEventListener('click', ()=>{ state.myNumber = myNumber.value.trim(); ls.set('px_my_number', state.myNumber); });
saveKey.addEventListener('click', ()=>{ state.aiKey = aiKey.value.trim() || window.AI_CONFIG?.GEMINI_API_KEY || ''; ls.set('px_ai_key', state.aiKey); alert(state.aiKey ? 'Key salva' : 'Sem key definida'); });
btnAdd.addEventListener('click', ()=>{ const phone = normalizePhone(cPhone.value.trim()); if(!phone) return; upsertContact(phone, {phone, name: cName.value.trim() || phone, notes: cNotes.value.trim()}, '', Date.now()); cName.value = cPhone.value = cNotes.value = ''; });
sendMsg.addEventListener('click', async ()=>{ const phone = state.current; const text = msgText.value.trim(); if(!phone || !text) return; await WABot.send({to: phone, text}); pushMsg(phone, {who:'me', text, ts: Date.now()}); msgText.value=''; renderThread(phone); });
function renderBot(){ botBadge.textContent = 'Bot: ' + (state.botOn? 'ON' : 'OFF'); toggleBot.textContent = state.botOn ? 'Desligar Bot' : 'Ligar Bot'; myNumber.value = state.myNumber || ''; aiKey.value = state.aiKey || window.AI_CONFIG?.GEMINI_API_KEY || ''; }
function renderContacts(){ contactsList.innerHTML = ''; const arr = Object.values(state.contacts).sort((a,b)=> (b.lastTs||0)-(a.lastTs||0)); if(arr.length===0){ contactsList.innerHTML='<p class="muted">Sem contatos ainda.</p>'; return; } arr.forEach(c => { const div = document.createElement('div'); div.className='msg'; div.innerHTML = `<strong>${escapeHtml(c.name||c.phone)}</strong><br><small class="muted">${escapeHtml(c.phone)} — ${escapeHtml(c.lastText||'')}</small>`; div.onclick = ()=> { state.current = c.phone; renderThread(c.phone); }; contactsList.appendChild(div); }); }
function renderThread(phone){ thread.innerHTML = ''; if(!phone){ threadTitle.textContent = 'Conversa'; return; } threadTitle.textContent = `Conversa — ${phone}`; const arr = state.threads[phone] || []; arr.forEach(m => { const div = document.createElement('div'); div.className = 'msg ' + (m.who==='me' ? 'me' : 'them'); const date = new Date(m.ts||Date.now()).toLocaleString(); div.innerHTML = `<small class="muted">${date}</small><br>${escapeHtml(m.text||'')}`; thread.appendChild(div); }); thread.scrollTop = thread.scrollHeight; }
function upsertContact(phone, data, lastText, ts){ const c = state.contacts[phone] || { phone }; state.contacts[phone] = { ...c, ...data, lastText, lastTs: ts }; ls.set('px_contacts', state.contacts); renderContacts(); }
function pushMsg(phone, m){ const arr = state.threads[phone] || []; arr.push(m); state.threads[phone] = arr; ls.set('px_threads', state.threads); }
async function aiReply({prompt, phone}){ const key = (state.aiKey || window.AI_CONFIG?.GEMINI_API_KEY || '').trim(); if(!key) return ''; const sys = `Você é um atendente virtual da PixelUp. Responda de forma educada, objetiva e peça dados essenciais (nome, necessidade, orçamento, prazo). Se o assunto for veículos, pergunte modelo/ano/valor. Se o contato pedir humano, responda que vai acionar o atendimento.`; const body = { contents:[{ parts:[ {text: sys + "\n\nPergunta do cliente: " + prompt } ] }] }; const r = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent", { method:'POST', headers:{ 'Content-Type':'application/json', 'x-goog-api-key': key }, body: JSON.stringify(body) }); if(!r.ok){ return ''; } const j = await r.json(); try{ const txt = j?.candidates?.[0]?.content?.parts?.[0]?.text || ''; return txt.trim(); }catch{ return ''; } }
function normalizePhone(p){ if(!p) return ''; return (''+p).replace(/[^0-9]/g,''); }
function escapeHtml(str){ return (str||'').replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"}[m])); }
function byId(id){ return document.getElementById(id); }